"""FilesinkAdapter - MP4/file recording sink for DeepStream pipelines"""

import gi

gi.require_version("Gst", "1.0")
from gi.repository import Gst

from sinks.base_sink import BaseSink


class FilesinkAdapter(BaseSink):
    """Sink adapter for recording to video files with H.264 encoding

    DeepStream compatible: uses nvvideoconvert with compute-hw for proper
    GPU->CPU memory transfer, avoiding memory corruption.

    Supports MP4 and AVI formats. AVI recommended for abrupt termination resilience.

    Pipeline: queue(30) -> nvvideoconvert(compute-hw=1) -> RGBA -> identity(ts) -> videoconvert -> x264enc -> AVI

    Fixes timestamp/PTS issues that cause horizontal/vertical lines (soc soc) by:
    - Using identity element to handle imperfect timestamps
    - Larger queues (30 buffers) to prevent frame drops
    - Proper encoder config for smooth GOP structure
    """

    _instance_counter = 0

    def __init__(
        self, location: str = "output.avi", codec: str = "h264", bitrate: int = 4000000
    ):
        """
        Args:
            location: Output file path (default: output.avi)
            codec: Video codec (default: h264)
            bitrate: Encoding bitrate in bps (default: 4000000 = 4 Mbps)
        """
        self.location = location
        self.codec = codec
        self.bitrate = bitrate
        self.elements = []
        self._id = FilesinkAdapter._instance_counter
        FilesinkAdapter._instance_counter += 1

    def create(self, pipeline: Gst.Pipeline) -> Gst.Element:
        """
        Create filesink pipeline for DeepStream:
        queue -> nvvideoconvert(compute-hw=1) -> caps(RGBA) -> identity(ts) -> videoconvert -> x264enc -> muxer -> filesink

        Key fixes for timestamp/PTS issues:
        - identity element to fix imperfect timestamps
        - Larger queues to prevent frame drops
        - Proper encoder config for smooth encoding
        """
        prefix = f"filesink{self._id}"

        queue_in = Gst.ElementFactory.make("queue", f"{prefix}_queue_in")
        queue_in.set_property("max-size-buffers", 30)
        queue_in.set_property("leaky", 2)
        queue_in.set_property("silent", True)

        nvvidconv = Gst.ElementFactory.make("nvvideoconvert", f"{prefix}_nvvidconv")
        nvvidconv.set_property("compute-hw", 1)
        nvvidconv.set_property("nvbuf-memory-type", 3)
        nvvidconv.set_property("silent", True)

        capsfilter = Gst.ElementFactory.make("capsfilter", f"{prefix}_caps")
        caps = Gst.Caps.from_string("video/x-raw, format=RGBA, memory:SystemMemory")
        capsfilter.set_property("caps", caps)
        capsfilter.set_property("silent", True)

        identity = Gst.ElementFactory.make("identity", f"{prefix}_identity")
        identity.set_property("silent", True)
        identity.set_property("drop-probability", 0)
        identity.set_property("error", False)

        videoconvert = Gst.ElementFactory.make("videoconvert", f"{prefix}_vidconv")
        videoconvert.set_property("silent", True)

        queue_enc = Gst.ElementFactory.make("queue", f"{prefix}_queue_enc")
        queue_enc.set_property("max-size-buffers", 30)
        queue_enc.set_property("leaky", 2)
        queue_enc.set_property("silent", True)

        encoder = Gst.ElementFactory.make("x264enc", f"{prefix}_encoder")
        encoder.set_property("bitrate", self.bitrate // 1000)
        encoder.set_property("speed-preset", "ultrafast")
        encoder.set_property("tune", "zerolatency")
        encoder.set_property("key-int-max", 30)
        encoder.set_property("b-adapt", 0)
        encoder.set_property("rc-lookahead", 0)
        encoder.set_property("threads", 1)

        parser = Gst.ElementFactory.make("h264parse", f"{prefix}_parser")
        parser.set_property("config-interval", -1)
        parser.set_property("silent", True)

        if self.location.endswith(".mp4"):
            muxer = Gst.ElementFactory.make("mp4mux", f"{prefix}_muxer")
            print("[FilesinkAdapter] Warning: MP4 may be corrupted if not properly closed")
        else:
            muxer = Gst.ElementFactory.make("avimux", f"{prefix}_muxer")

        filesink = Gst.ElementFactory.make("filesink", f"{prefix}_sink")
        filesink.set_property("location", self.location)
        filesink.set_property("sync", False)
        filesink.set_property("async", False)

        required = [queue_in, nvvidconv, capsfilter, identity, videoconvert, queue_enc, encoder, parser, muxer, filesink]
        if not all(required):
            missing = [name for elem, name in zip(required,
                ["queue_in", "nvvidconv", "capsfilter", "identity", "videoconvert", "queue_enc", "encoder", "parser", "muxer", "filesink"])
                if elem is None]
            raise RuntimeError(f"Failed to create filesink elements: {missing}")

        for elem in required:
            pipeline.add(elem)

        chain = [queue_in, nvvidconv, capsfilter, identity, videoconvert, queue_enc, encoder, parser, muxer, filesink]
        for i in range(len(chain) - 1):
            if not chain[i].link(chain[i + 1]):
                raise RuntimeError(f"Failed to link {chain[i].get_name()} -> {chain[i + 1].get_name()}")

        self.elements = chain

        mux_type = "AVI" if not self.location.endswith(".mp4") else "MP4"
        print(f"[FilesinkAdapter] Created: queue(30) -> nvvidconv(compute-hw=1) -> RGBA -> identity(ts) -> x264enc -> {mux_type}")

        return queue_in

    def start(self) -> None:
        print(f"[FilesinkAdapter] Recording to: {self.location}")

    def stop(self) -> None:
        print(f"[FilesinkAdapter] Recording stopped: {self.location}")
